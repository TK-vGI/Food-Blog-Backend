# Stage 5/5: First interface
## Description
You decided to build a simple database query interface. The search results will be displayed on the screen,  
but in the future, you may want to create JSON files, load them in the frontend and show them in a browser... Stop!  
For now, the screen should suffice.

Today you want to eat a dish that will contain strawberries and milk, so you decide to build a query to the database  
which will return all dishes that contain both ingredients. Thanks to this, you will learn what else you need to buy  
for selected recipes. And since you're not interested in dinner dishes, you decide to add a second condition to find  
dishes that are appropriate for the time of day.

Next week you have an appointment with your great-grandmother, so you can ask about a few unreadable recipes,  
and maybe also show her what you have done.

## Objectives
1. Pass two new parameters to the script: `ingredients` and `meals`. The parameters are not mandatory. If the new  
   parameters are not passed, the script should work like in the previous stage.
2. The `--ingredients` parameter should contain a list of ingredients separated by commas: `--ingredients="milk,sugar,tea"`.
3. The `--meals` parameter should contain a list of meals separated by commas `--meals="dinner,supper"`.
4. You should search the database for all the recipes which contain all the passed ingredients (recipes may contain  
   other ingredients as well) and can be served at a specific mealtime. If there are recipes that meet the conditions,  
   print their names after a colon, separated by a comma. If you find two recipes with the same name print both names.
5. If there are no such recipes, print: `There are no such recipes in the database`.
6. This time we will check the output, so make sure that the last line you print contains the expected elements.
7. You do not need to validate the arguments The tests will pass the correct values.

**Tip**: If you can't build complex SQL queries, you can always work on the results of simpler queries using lists and sets.
**Tip**: The logic of the query should be (ingredient1 AND ingredient2 AND ...) AND (meal1 OR meal2 OR ...)

## Examples
The greater-than symbol followed by a space (> ) represents the user input. Note that it's not part of the input.
### Example 1(data input):
```markdown
> python food_blog.py food_blog.db
Pass the empty recipe name to exit.
Recipe name: > Milkshake
Recipe description: > Blend all ingredients and put in the fridge.
1) breakfast  2) brunch  3) lunch  4) supper
Enter proposed meals separated by a space: > 1 3 4
Input quantity of ingredient <press enter to stop>: > 500 ml milk
Input quantity of ingredient <press enter to stop>: > 1 cup strawberry
Input quantity of ingredient <press enter to stop>: > 1 tbsp sugar
Input quantity of ingredient <press enter to stop>: >
Pass the empty recipe name to exit.
Recipe name: > Hot cacao
Recipe description: > Pour the ingredients into the hot milk. Mix it up.
1) breakfast  2) brunch  3) lunch  4) supper
Enter proposed meals separated by a space: > 1 2
Input quantity of ingredient <press enter to stop>: > 250 ml milk
Input quantity of ingredient <press enter to stop>: > 2 tbsp cacao
Input quantity of ingredient <press enter to stop>: >
Pass the empty recipe name to exit.
Recipe name: > Hot cacao
Recipe description: > Pour the ingredients into the hot milk. Mix it up.
1) breakfast  2) brunch  3) lunch  4) supper
Enter proposed meals separated by a space: > 1 4
Input quantity of ingredient <press enter to stop>: > 250 ml milk
Input quantity of ingredient <press enter to stop>: > 2 tbsp cacao
Input quantity of ingredient <press enter to stop>: > 1 tsp sugar
Input quantity of ingredient <press enter to stop>: >
Pass the empty recipe name to exit.
Recipe name: > Fruit salad
Recipe description: > Cut strawberries and mix with other fruits. you can sprinkle everything with sugar.
1) breakfast  2) brunch  3) lunch  4) supper
Enter proposed meals separated by a space: > 3 4
Input quantity of ingredient <press enter to stop>: > 10 strawberry
Input quantity of ingredient <press enter to stop>: > 50 g black
Input quantity of ingredient <press enter to stop>: > 1 cup blue
Input quantity of ingredient <press enter to stop>: > 1 tsp sugar
Input quantity of ingredient <press enter to stop>: >
Pass the empty recipe name to exit.
Recipe name: > 
```
### Example 2:
```markdown
> python food_blog.py food_blog.db --ingredients="sugar,milk" --meals="breakfast,brunch"
Recipes selected for you: Hot cacao, Milkshake
```
### Example 3:
```markdown
> python food_blog.py food_blog.db --ingredients="sugar,milk,strawberry" --meals="brunch"
There are no such recipes in the database.
```

## Solution:
```python
import sqlite3
import argparse

# DB_NAME = "food_blog.db"
# DB_NAME = "C:/Users/tomas/PycharmProjects/Food Blog Backend/Food.db"

data = {"meals": ("breakfast", "brunch", "lunch", "supper"),
        "ingredients": ("milk", "cacao", "strawberry", "blueberry", "blackberry", "sugar"),
        "measures": ("ml", "g", "l", "cup", "tbsp", "tsp", "dsp", "")}


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("db_name")
    parser.add_argument("--ingredients")
    parser.add_argument("--meals")
    return parser.parse_args()


def query_recipes(conn, ingredient_names, meal_names):
    cur = conn.cursor()

    # Convert ingredient names → ids
    ingredient_ids = []
    for name in ingredient_names:
        cur.execute("SELECT ingredient_id FROM ingredients WHERE ingredient_name = ?;", (name,))
        row = cur.fetchone()
        if not row:
            print("There are no such recipes in the database.")
            return

        ingredient_ids.append(row[0])

    # Convert meal names → ids
    meal_ids = []
    for name in meal_names:
        cur.execute("SELECT meal_id FROM meals WHERE meal_name = ?;", (name,))
        row = cur.fetchone()
        if not row:
            print("There are no such recipes in the database.")
            return

        meal_ids.append(row[0])

    # Build SQL placeholders
    ing_placeholders = ",".join("?" * len(ingredient_ids))
    meal_placeholders = ",".join("?" * len(meal_ids))

    sql = f"""
        SELECT recipe_name
        FROM recipes
        WHERE recipe_id IN (
            SELECT recipe_id
            FROM quantity
            WHERE ingredient_id IN ({ing_placeholders})
            GROUP BY recipe_id
            HAVING COUNT(DISTINCT ingredient_id) = {len(ingredient_ids)}
        )
        AND recipe_id IN (
            SELECT recipe_id
            FROM serve
            WHERE meal_id IN ({meal_placeholders})
        )
        ORDER BY recipe_name;
    """

    cur.execute(sql, ingredient_ids + meal_ids)
    rows = cur.fetchall()

    if rows:
        names = ", ".join(r[0] for r in rows)
        print(f"Recipes selected for you: {names}")
    else:
        print("There are no such recipes in the database.")


def create_stage1(conn, data):
    conn.execute("""
        CREATE TABLE IF NOT EXISTS meals(
            meal_id INTEGER PRIMARY KEY,
            meal_name TEXT UNIQUE NOT NULL
        );
    """)

    conn.execute("""
        CREATE TABLE IF NOT EXISTS ingredients(
            ingredient_id INTEGER PRIMARY KEY,
            ingredient_name TEXT UNIQUE NOT NULL
        );
    """)

    conn.execute("""
        CREATE TABLE IF NOT EXISTS measures(
            measure_id INTEGER PRIMARY KEY,
            measure_name TEXT UNIQUE
        );
    """)

    # Check if meals table already has data
    cur = conn.cursor()
    cur.execute("SELECT COUNT(*) FROM meals;")
    if cur.fetchone()[0] == 0:
        # Only insert if empty
        for table, values in data.items():
            column = table[:-1] + "_name"
            conn.executemany(
                f"INSERT INTO {table} ({column}) VALUES (?);",
                [(v,) for v in values]
            )
        conn.commit()


def create_stage2(conn):
    conn.execute("""
                CREATE TABLE IF NOT EXISTS recipes
                (
                    recipe_id          INTEGER PRIMARY KEY,
                    recipe_name        TEXT NOT NULL,
                    recipe_description TEXT
                );
                """)
    conn.commit()


def create_stage3(conn):
    conn.execute("""
                 CREATE TABLE IF NOT EXISTS serve
                 (
                     serve_id  INTEGER PRIMARY KEY,
                     recipe_id INTEGER NOT NULL,
                     meal_id   INTEGER NOT NULL,
                     FOREIGN KEY (recipe_id) REFERENCES recipes (recipe_id),
                     FOREIGN KEY (meal_id) REFERENCES meals (meal_id)
                 );
                 """)
    conn.commit()


def create_stage4(conn):
    conn.execute("""
                 CREATE TABLE IF NOT EXISTS quantity
                 (
                     quantity_id   INTEGER PRIMARY KEY,
                     quantity      INTEGER NOT NULL,
                     recipe_id     INTEGER NOT NULL,
                     measure_id    INTEGER NOT NULL,
                     ingredient_id INTEGER NOT NULL,
                     FOREIGN KEY (recipe_id) REFERENCES recipes (recipe_id),
                     FOREIGN KEY (measure_id) REFERENCES measures (measure_id),
                     FOREIGN KEY (ingredient_id) REFERENCES ingredients (ingredient_id)
                 );
                 """)
    conn.commit()


def add_recipe(conn, name, description, serving, ingredients):
    cur = conn.cursor()

    # Insert recipe
    cur.execute("""
        INSERT INTO recipes (recipe_name, recipe_description)
        VALUES (?, ?);
    """, (name, description))
    recipe_id = cur.lastrowid

    # Insert into serve table
    for meal_id in serving.split():
        cur.execute("""
            INSERT INTO serve (recipe_id, meal_id)
            VALUES (?, ?);
        """, (recipe_id, int(meal_id)))

    # --- insert into quantity ---
    for part in ingredients:
        cur.execute("""
                    INSERT INTO quantity (quantity, recipe_id, measure_id, ingredient_id)
                    VALUES (?, ?, ?, ?);
                    """, (part[0], recipe_id, part[1], part[2]))

    conn.commit()


def prompt_for_recipe(conn):
    cur = conn.cursor()

    recipe_name = input("Recipe name: ").strip()
    if recipe_name == "":
        return None  # signal to stop

    recipe_description = input("Recipe description: ").strip()
    recipe_serving = input(
        "1) breakfast  2) brunch  3) lunch  4) supper \n"
        "Enter proposed meals separated by a space: "
    ).strip()

    material = []
    # Ingredient loop "quantity measure ingredient"
    while True:
        line = input("Input quantity of ingredient <press enter to stop>: ").strip()
        if line == "":
            break

        parts = line.split()
        quantity = int(parts[0])

        if len(parts) == 2:
            measure = ""
            ingredient = parts[1]
        else:
            measure = parts[1]
            ingredient = " ".join(parts[2:]) # if ingredient consists of more words
            # ingredient = parts[2] # test project provides only single word ingredients

        # --- match measure ---
        if measure != "":
            cur.execute("""
                        SELECT measure_id, measure_name
                        FROM measures
                        WHERE measure_name LIKE ?;
                        """, (measure + "%",)
                        )
            measures = cur.fetchall()

            if len(measures) != 1:
                print("The measure is not conclusive!")
                continue
        else:
            measures = ("8","")

        measure_id = measures[0][0]


        # --- match ingredient ---
        cur.execute("""
                    SELECT ingredient_id, ingredient_name
                    FROM ingredients
                    WHERE ingredient_name LIKE ?;
                    """, ("%" + ingredient + "%",)
                    )
        ingredients = cur.fetchall()

        if len(ingredients) != 1:
            print("The ingredient is not conclusive!")
            continue

        ingredient_id = ingredients[0][0]

        material.append((quantity,measure_id,ingredient_id))

    return recipe_name, recipe_description, recipe_serving, material


def main():
    args = parse_args()

    conn = sqlite3.connect(args.db_name)
    cur = conn.cursor()
    cur.execute("PRAGMA foreign_keys = ON;")

    create_stage1(conn, data)
    create_stage2(conn)
    create_stage3(conn)
    create_stage4(conn)

    # --- Stage 5: Query mode ---
    if args.ingredients or args.meals:
        ingredient_name = args.ingredients.split(",") if args.ingredients else []
        meal_name = args.meals.split(",") if args.meals else []
        query_recipes(conn, ingredient_name, meal_name)
        conn.close()
        return

    # --- Stage 4: Data entry mode ---
    while True:
        print("Pass the empty recipe name to exit.")
        result = prompt_for_recipe(conn)
        if result is None:
            break

        name, description, serving, ingredients = result
        add_recipe(conn, name, description, serving, ingredients)

    conn.close()



if __name__ == "__main__":
    main()
```