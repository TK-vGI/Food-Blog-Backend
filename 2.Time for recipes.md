# Stage 2/5: Time for recipes!
## Description

It is time to create the main recipe table. You decided to store the recipe name and description in the main table.  
You wanted to indicate which meal suits the dish best, but your great-grandmother told you that it doesn't have  
to be just one meal. So you have to think about the solution. You also need to build a tool that will allow you  
to fill your database with data.

Below is a diagram of the database tables. 

![Database explanation](IMG2.png)

## Objectives
1. Create a table named `recipes` with three columns: `recipe_id` of an `integer` type with the `primary key` attribute,  
   `recipe_name` of a `text` type with the `not-null` attribute, and `recipe_description` of a `text` type.
2. Prepare a simple system that allows you to populate this table. Ask for the recipe name and the cooking directions,  
   and insert the data into the table.
3. When a zero-length string is entered for the recipe name the script should terminate. Remember to commit your  
   changes and close the database.
4. Remember! You can print anything you want. Tests will check only the database file that your script will create  
   and populate.
5. You do not need to validate the entered data. The tests will pass the correct values.

Tip: The primary key cell of an integer type will be incremented automatically. You only need to insert values  
to other columns.

## Example
The greater-than symbol followed by a space (> ) represents the user input. Note that it's not part of the input.
```markdown
> python food_blog.py food_blog.db
Pass the empty recipe name to exit.
Recipe name: > Cold milk
Recipe description: > Freeze milk
Recipe name: > Hot milk
Recipe description: > Boil milk
Recipe name: >
```

## Solution:
```python
import sqlite3

DB_NAME = "food_blog.db"
# DB_NAME = "C:/Users/tomas/PycharmProjects/Food Blog Backend/Food.db"

data = {"meals": ("breakfast", "brunch", "lunch", "supper"),
        "ingredients": ("milk", "cacao", "strawberry", "blueberry", "blackberry", "sugar"),
        "measures": ("ml", "g", "l", "cup", "tbsp", "tsp", "dsp", "")}

def create_stage1(conn, data):
    conn.execute("CREATE TABLE IF NOT EXISTS meals("
                "meal_id INT PRIMARY KEY,"
                "meal_name TEXT UNIQUE NOT NULL);")

    conn.execute("CREATE TABLE IF NOT EXISTS ingredients("
                "ingredient_id INT PRIMARY KEY,"
                "ingredient_name TEXT UNIQUE NOT NULL);")

    conn.execute("CREATE TABLE IF NOT EXISTS measures("
                "measure_id INT PRIMARY KEY,"
                "measure_name TEXT UNIQUE);")

    for table, values in data.items():
        column = table[:-1] + "_name"  # meals â†’ meal_name
        conn.executemany(
            f"INSERT INTO {table} ({column}) VALUES (?);",
            [(v,) for v in values]
        )
    conn.commit()

def add_recipe(conn, name, description):
    conn.execute("""
        INSERT INTO recipes (recipe_name, recipe_description)
        VALUES (?, ?);
    """, (name, description))
    conn.commit()


def main():
    with sqlite3.connect(DB_NAME) as conn:
        cur = conn.cursor()

        # Create database food_blog.db, tables
        create_stage1(conn, data)

        # Create table recipe
        cur.execute("""
                    CREATE TABLE IF NOT EXISTS recipes
                    (
                        recipe_id          INTEGER PRIMARY KEY,
                        recipe_name        TEXT NOT NULL,
                        recipe_description TEXT
                    );
                    """)
        conn.commit()

        # Populate table
        while True:
            recipe_name = input("Recipe name: ").strip()
            if recipe_name == "":
                break

            recipe_description = input("Recipe description: ").strip()
            add_recipe(conn, recipe_name,recipe_description)

    conn.close()


if __name__ == "__main__":
    main()
```